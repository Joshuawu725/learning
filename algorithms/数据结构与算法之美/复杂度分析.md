# 数据结构与算法之美



## 复杂度分析（上）

### 为什么需要复杂度分析

事后统计法不足

1.测试结构非常依赖测试环境

2.测试结构受数据规模的影响很大

所以需要一个不用具体的测试数据来测试，就可以粗略的估计计算法的执行效率的方法



### 大O复杂度表示法

代码运行的执行时间T(n)与每行代码的执行次数成正比

当n很大的时候就可以忽略公式中的低阶常量系数等



### 时间复杂度分析

1.只关注循环执行次数最多的一段代码

2.加法法则：总复杂程度等于量级最大的那段代码的复杂度

3.乘法法则：嵌套代码的复杂程度等于嵌套内外代码复杂度的乘积



### 几种常见的时间复杂度实例分析

多项式量级

常量阶O(1)

对数阶O(logn)

线性阶O(n)

线性对数阶O(nlogn)

平方价O(n²) 立方阶O(n³) K次方阶



非多项式量级

指数阶O(2ⁿ)

阶乘阶O(n!)



1.O(1) 

一般情况下，只要算法中不存在循环语句、递归语句即使有成千上万的代码其复杂程度也是O(1)

2.O(logn) O(nlogn)

```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

3.O(m+n)、O(m*n)

代码的复杂程度由两个数据的规模决定

```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

由于无法事时限评估m n的量级，所以用加法法则 O(m+n) 



### 空间复杂度

渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。

常见的空间复杂度就是 O(1)、O(n)、O(n² )



### 小结

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n²  )。

![](img\497a3f120b7debee07dc0d03984faf04.jpg)



## 复杂度分析（下）

### 最好 最坏时间复杂度

```
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

在这个例子中，在数组中寻找变量出现的位置 但是X出现的位置是随机的 也许是第一的 也许不再数组中需要全部遍历一般 所以不同情况下这段代码的时间复杂程度不一样

因此 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度



### 平均情况时间复杂度

 在这里例子中 引入概率知识 

要查找的变量 x，要么在数组里，要么就不在数组里我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。

通过加权平均 也就是期望 我们得知这段代码的加权平均时间复杂度仍然是 O(n)

在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分



### 均摊时间复杂度

```
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。

首选最好情况 数组有空余，直接插入 时间复杂度O(1)。最坏情况，数组中没有空间， 先进行一次遍历求和 再插入 复杂度为O(n)

平均复杂度：假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：O(1)

但是与之前的find()相比insert()有很多不一样

首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()第一个区别于 find() 的地方。

对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。

针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。

每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

**摊还分析就是将一个复杂操作的耗时 平摊到其他复杂程度较低的操作上**