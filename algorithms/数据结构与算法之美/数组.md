# 数据结构与算法之美

## 数组

### 如何实现随机访问

**数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。**

A.线性表

线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

B.连续的内存空间和相同类型的数据

```
a[i]_address = base_address + i * data_type_size
```

计算机通过这个寻址公式可以计算出该元素储存的内存地址

链表适合插入、删除，时间复杂度 O(1) **数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)**

### 低效的“插入”和“删除”

因为数组为了保持内存数据的连续性 当插入时 需要将插入位置后的元素往后移动一位 而当删除时 需要将删除位置之后的元素往前移动一位 所以数组插入和删除的时间复杂对都是O(n)

但是又一些特殊操作 

![](img\3f70b4ad9069ec568a2caaddc231b7dc.jpg)

在插入时 不管顺序 将原来位置的元素移动到末尾 时间复杂度可以变为O(1)



![](img\b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg)

依次删除a b c 时，我们可以先记录下已经删除的数据，每次删除操作只是用作标记，当数组没有更多的储存空间时 在执行一次真正的删除操作 这样可以减少删除操作导致的数据搬移。

PS: 类似于JVM标记清除垃圾回收算法的核心思想



### 警惕数组访问越界

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

在这段代码中 由于约束条件出错 同时 a[3] (函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i ) 导致数组访问越界 会循环打印

在java 中会做出越界检查



### 容器能否完全替代数组

在java中 ArrayList 最大的优势就是可以将很多数组操作的细节封装起来  同时支持动态扩容 每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小

但是 一些容器无法储存基本类型

同时在使用多维数组使 使用数组更加直观



